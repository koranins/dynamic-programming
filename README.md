# Key ideas

- 2 common use-cases
  - find optimal solution
  - count total number of solutions for a problem
- how?
  - identify sub problems
- top-down
  - solve problems first then add memoization
  - `Dynamic Programming = Recursion + Memoization`

- bottom-up
  - solve sub problems first